module hello_linux;

#only(#comptime)
func build() -> #Compilation {
    $$unused int meme;
    #Target t;
    #Array<<int>> arr;
    t.name = "linux-minimal";
    t.entrypoint = linux_main;
    t.convention = {
        
    };
    t.generate = x64_codegen;
    t.assemble = x64_assemble;

    let ctx = #Compilation {};
    ctx.targets += t;
    return ctx;
}

#only(#comptime)
func x64_codegen(#ByteVector writer, <<#String>> tokens, #Ast ast) {
    
}

#only(#comptime)
func x64_assemble(#ByteVector writer, <<#String>> words, <<#Instruction>> instructions) {
    let register_table = <<#String>> {
        "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
        "8", "9", "10", "11", "12", "13", "14", "15"
    });
    repeat ins.count with i {
        ^Instruction ins = instructions @ i;
        let op = words[ins[i].parts[0]];
        if op == "mov" {
            let register = #index_match(register_table, #make_slice(words[ins[i].parts[1]], 1));
            writer.add(byte(0xb8 + register), #le32bytes(#to_int(words[ins[i].parts[2]])));
        }
        else if op == "lea" {
            let dst_reg = #index_match(register_table, #make_slice(words[ins[i].parts[1]], 1));
            let src_reg = #index_match(register_table, #make_slice(words[ins[i].parts[2]], 1));
            writer.add(0x48, 0x8d, byte(0x05 + dst_reg * 8), #le32bytes(#to_int(words[ins[i].parts[3]])));
        }
        else if op == "syscall" {
            writer.add(0x0f, 0x05);
        }
    }
}

func linux_main() {
    let hello = "Hello World!\n";
    let WRITE_FUNC = 1;
    let STDOUT = 1;
    #asm {
        mov eax, WRITE_FUNC
        lea rcx, [rip + #rel_pc(call_write+1)]
        mov edi, STDOUT
        lea rsi, [rip + #rel_pc(hello.ptr)]
        mov edx, hello.bytecount
        call_write:
        syscall
        xor eax, eax
        leave
        ret
    }
}
